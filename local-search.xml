<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【LeetCode】145.二叉树的后续遍历</title>
    <link href="/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>给你一棵二叉树的根节点 root ，返回其节点值的 <strong>后序</strong> 遍历 。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/b17249866b98973447035d4bf6648b45.jpeg#pic_center" alt="图1"></p><blockquote><p>输入：root &#x3D; [1,null,2,3]<br>输出：[3,2,1]</p></blockquote><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><blockquote><p>输入：root &#x3D; []<br>输出：[]</p></blockquote><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><blockquote><p>输入：root &#x3D; [1]<br>输出：[1]</p></blockquote><p><strong>提示</strong>：</p><ul><li>树中节点的数目在范围 [0, 100] 内</li><li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li></ul><h1 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h1><p>二叉树的后序遍历规则：左-右-根，解题思路其实和前面两篇<a href="https://zyxelva.github.io/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/">二叉树的前序遍历</a>、<a href="https://zyxelva.github.io/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/">二叉树的中序遍历</a>差不太多.</p><h2 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1 递归"></a>2.1 递归</h2><p>定义函数 postOrderTraversal(root)为遍历root节点。则调用顺序为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">postOrderTraversal(root.left);<br>postOrderTraversal(root.right);<br>root.val;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p></li><li><p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log⁡n)，最坏情况下树呈现链状，为 O(n)。</p></li></ul><h2 id="2-2-迭代"><a href="#2-2-迭代" class="headerlink" title="2.2 迭代"></a>2.2 迭代</h2><ol><li>遍历root<br><img src="https://img-blog.csdnimg.cn/img_convert/7af3c2bb2c4365ed4c37aefa8a4a3c6e.png#pic_center" alt="图2"></li><li>root入栈<br><img src="https://img-blog.csdnimg.cn/img_convert/9070a7206c86a1ea612fc04ec2f71a00.png#pic_center" alt="图3"><br>3）root.left入栈<br><img src="https://img-blog.csdnimg.cn/img_convert/857102064a004707e583721556231ba5.png#pic_center" alt="图4"><br>4）root.left再无左子树了，左子树根节点出栈，遍历，并标记当前出栈的节点为已访问过，否则遍历、入栈root.right<br><img src="https://img-blog.csdnimg.cn/img_convert/f002bede3c25ca19cb98e36727b302aa.png#pic_center" alt="图5"><br><img src="https://img-blog.csdnimg.cn/img_convert/1372fe88616786229ad090b22fbd30cf.png#pic_center" alt="图6"><br><img src="https://img-blog.csdnimg.cn/img_convert/b033abfd3c38a61cf2febbc3cabb69ec.png#pic_center" alt="图7"><br><img src="https://img-blog.csdnimg.cn/img_convert/765e04b0d1cda730a3ba05243a079ef7.png#pic_center" alt="图8"></li></ol><p>5）同理，先把4所有左节点入栈，到达最左节点后，出栈，遍历val，标记当前出栈的节点为已访问过，遍历root.right，出栈root.right，root.<br><img src="https://img-blog.csdnimg.cn/img_convert/37c2e0b67765c6b6a219cf3e21864db2.png#pic_center" alt="图9"><br>5出栈<br><img src="https://img-blog.csdnimg.cn/img_convert/349c04a123e6d5fe20da5a184eb3cb9b.png#pic_center" alt="图10"><br><img src="https://img-blog.csdnimg.cn/img_convert/611d2d7e7ffe0f43fe396655e31a4fff.png#pic_center" alt="图11"><br>4出栈，但4的右节点存在，入栈4.right<br><img src="https://img-blog.csdnimg.cn/img_convert/733a9e18379af93d68e5173774b2d1f2.png#pic_center" alt="图12"><br><img src="https://img-blog.csdnimg.cn/img_convert/022d50585c4aaafd920d3a590c48ea3f.png#pic_center" alt="图13"><br><img src="https://img-blog.csdnimg.cn/img_convert/701a24fb73d25b6e2fed1a31317d31ca.png#pic_center" alt="图14"><br>7出栈，遍历，依次出栈4，3，遍历完毕<br><img src="https://img-blog.csdnimg.cn/img_convert/ddee700bc6ee3175f2c8007270d340ec.png#pic_center" alt="图15"><br><img src="https://img-blog.csdnimg.cn/img_convert/ffb6ce833111af31275a768dc5888df1.png#pic_center" alt="图16"><br><img src="https://img-blog.csdnimg.cn/img_convert/f89ee6166faf12b4f89d048abfc08569.png#pic_center" alt="图17"><br><img src="https://img-blog.csdnimg.cn/img_convert/885f14118fa6d9c7801c914926e1c5b3.png#pic_center" alt="图18"><br><img src="https://img-blog.csdnimg.cn/img_convert/9deb56a376dec731acd2e6cf3cb4c3d0.png#pic_center" alt="图19"><br><img src="https://img-blog.csdnimg.cn/img_convert/bd7589948385a47db4365d8182abd12d.png#pic_center" alt="图20"><br><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p></li><li><p>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(log⁡n)，最坏情况下树呈现链状，为 O(n)。</p></li></ul><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">//迭代</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> != current || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> != current) &#123;<br>                stack.push(current);<br>                current = current.left;<br>            &#125;<br>            <span class="hljs-comment">//获取当前栈顶节点</span><br>            current = stack.peek();<br>            <span class="hljs-comment">//右节点为空，或者已经访问过，则打印，并标记当前出栈的节点为已访问过</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == current.right || prev == current.right) &#123;<br>                res.add(current.val);<br>                prev = current;<br>                stack.pop();<br>                current = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                current = current.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-comment">//递归</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] postorderTraversal2 (TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        postorderTraversal2(list, root);<br>        <span class="hljs-keyword">return</span> list.stream().mapToInt(Integer::valueOf).toArray();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorderTraversal2</span> <span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorderTraversal2(list, root.left);<br>        postorderTraversal2(list, root.right);<br>        list.add(root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】94.二叉树的中序遍历</title>
    <link href="/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>给定一个二叉树的根节点 root ，返回 它的 <strong>中序</strong> 遍历 。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/7c55ac8a6fe7df8e5a4939e503566cb5.jpeg#pic_center" alt="图1"></p><blockquote><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]</p></blockquote><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><blockquote><p>输入：root &#x3D; []<br>输出：[]</p></blockquote><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><blockquote><p>输入：root &#x3D; [1]<br>输出：[1]</p></blockquote><p><strong>提示</strong>：</p><ul><li>树中节点数目在范围 [0, 100] 内</li><li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li></ul><h1 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h1><h2 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1 递归"></a>2.1 递归</h2><p>类似<a href="https://zyxelva.github.io/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/">二叉树的前序遍历</a>，中序遍历规则为 左-根-右，只要对前序遍历-递归稍作调整，即可实现；</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p></li><li><p>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p></li></ul><h2 id="2-2-迭代（栈）"><a href="#2-2-迭代（栈）" class="headerlink" title="2.2 迭代（栈）"></a>2.2 迭代（栈）</h2><p>若利用栈（迭代思想），则需要调整下入栈顺序，遍历顺序<br>1）先遍历根节点，入栈<br><img src="https://img-blog.csdnimg.cn/img_convert/346ead11b93d1e268442d3268d22c544.png#pic_center" alt="图2"><br>2）循环遍历左子树<br><img src="https://img-blog.csdnimg.cn/img_convert/c423efbaa00943b29c58b1a55e20e802.png#pic_center" alt="图3"><br><img src="https://img-blog.csdnimg.cn/img_convert/795f1e51a84546e874987a7ac8425e7f.png#pic_center" alt="图4"><br>3）到达最左边，出栈，遍历该节点右子树，入栈，没有的话，再出栈该节点的根节点，比如目前节点是4，右子树没有了，出栈根节点2<br><img src="https://img-blog.csdnimg.cn/img_convert/37ff491c7c271fb4f326cc57a74f4122.png#pic_center" alt="图5"><br><img src="https://img-blog.csdnimg.cn/img_convert/7aa96355593a980611f6c2298e71009b.png#pic_center" alt="图6"><br><img src="https://img-blog.csdnimg.cn/img_convert/431308dd45151de979645577be90e040.png#pic_center" alt="图7"><br><img src="https://img-blog.csdnimg.cn/img_convert/f62bc4615e0da03a3e45d9a64acd158b.png#pic_center" alt="图8"></p><p>4）根节点的左子树遍历完毕，开始遍历1的右子树，先出栈根节点1，同理遍历右子树<br><img src="https://img-blog.csdnimg.cn/img_convert/75966ba0cf835e89054d0fd5c4824a56.png#pic_center" alt="图9"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b28df401f758e0b0c558c52f5ef1b08c.png#pic_center" alt="图10"><br><img src="https://img-blog.csdnimg.cn/img_convert/ad63fdcac27c54c96ad5c202f804e81f.png#pic_center" alt="图11"><br><img src="https://img-blog.csdnimg.cn/img_convert/6dfe1efa71dc1da0ff6b115bbeb46f2f.png#pic_center" alt="图12"><br><img src="https://img-blog.csdnimg.cn/img_convert/db58b8ed3cdde4808ecc14551cd02fd5.png#pic_center" alt="图13"><br><img src="https://img-blog.csdnimg.cn/img_convert/ac29b2347b8098dc63cd4be6e7496bc2.png#pic_center" alt="图14"><br><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p></li><li><p>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p></li></ul><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *   int val = 0;</span><br><span class="hljs-comment"> *   TreeNode left = null;</span><br><span class="hljs-comment"> *   TreeNode right = null;</span><br><span class="hljs-comment"> *   public TreeNode(int val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 递归算法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root TreeNode类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型一维数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] inorderTraversal2 (TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        inorderTraversal2(list, root);<br>        <span class="hljs-keyword">return</span> list.stream().mapToInt(Integer::valueOf).toArray();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraversal2</span> <span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorderTraversal2(list, root.left);<br>        list.add(root.val);<br>        inorderTraversal2(list, root.right);<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    非递归算法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] inorderTraversal (TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-comment">//把左节点所有左节点入栈</span><br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            <span class="hljs-comment">//出栈</span><br>            top = stack.pop();<br>            list.add(top.val);<br>            cur = top.right;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            arr[i] = list.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】102.二叉树的层序遍历</title>
    <link href="/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p> <img src="https://img-blog.csdnimg.cn/img_convert/2e1724d19c6520ecce7f331873f7bee9.jpeg#pic_center" alt="图1"></p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><blockquote><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p></blockquote><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><blockquote><p>输入：root &#x3D; [1]<br>输出：[[1]]</p></blockquote><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><blockquote><p>输入：root &#x3D; []<br>输出：[]</p></blockquote><p><strong>提示</strong>：</p><ul><li>树中节点数目在范围 [0, 2000] 内</li><li>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</li></ul><h1 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h1><h2 id="2-1-队列"><a href="#2-1-队列" class="headerlink" title="2.1 队列"></a>2.1 队列</h2><p>二叉树每层的遍历符合队列的特性，必须FIFO(first in first out)，再遍历每层完成后，可以给定一个标记或者层数，表示该层已经遍历完毕，可以将此时的该层遍历结果输出。伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义队列</span><br>Queue q;<br><span class="hljs-comment">//结果集</span><br>List res;<br><span class="hljs-comment">//root 入队</span><br>q.add(root);<br><span class="hljs-comment">//给定一个标识，标记第一层遍历的结尾</span><br>q.add(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">while</span>(q不为空)&#123;<br><span class="hljs-comment">//出队</span><br>temp=q.peek();<br><span class="hljs-comment">//不是标识的话，入队root.left、root.right</span><br><span class="hljs-keyword">if</span>(temp不为<span class="hljs-literal">null</span>)&#123;<br>res.add(temp.val);<br><span class="hljs-keyword">if</span>(temp.left不为<span class="hljs-literal">null</span>)&#123;<br>q.add(temp.left);<br>&#125;<br><span class="hljs-keyword">if</span>(temp.right不为<span class="hljs-literal">null</span>)&#123;<br>q.add(temp.right);<br>&#125;<br>&#125;<br><span class="hljs-comment">//否则，该层遍历完毕</span><br><span class="hljs-keyword">else</span> &#123;<br>q.add(<span class="hljs-literal">null</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/774fe28d36b44dfdda1b8167197e72e6.gif#pic_center" alt="图2"><br><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)，其中n为二叉树的节点数，每个节点访问一次</li><li>空间复杂度：O(n)，队列的空间为二叉树的一层的节点数，最坏情况二叉树的一层为O(n)级</li></ul><h2 id="2-2-递归"><a href="#2-2-递归" class="headerlink" title="2.2 递归"></a>2.2 递归</h2><p>根据二叉树的定义，不难看出，每个节点都有类似的性质。当遍历发生时，对于其左右子树同样适用相同的规则，非常适合递归。可以借鉴之前对于二叉树的前中后序遍历，既然可以用递归解决，那层次遍历也未尝不可。同样可以运用标记的思想，对于同一层，可以标记为相同的深度来进行遍历。伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span>;<br><br><span class="hljs-comment">//计入子节点，则深度depth+1</span><br><span class="hljs-comment">//递归左右时深度记得加1</span><br>traverse(root.left, depth + <span class="hljs-number">1</span>); <br>traverse(root.right, depth + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//每个节点值放入对应的二维数组相应行</span><br>res[depth - <span class="hljs-number">1</span>].push_back(root-&gt;val);<br><br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，n为节点数量，DFS对每个节点访问一次，因此递归调用n次，每次调用执行常数次操作，时间复杂度O(n)。</li><li>空间复杂度：O(n)，空间复杂度在于递归调用深度和每次递归调用辅助空间，辅助空间为常数级，与节点深度相关，当节点深度为n时最大，为O(n)。</li></ul><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *   int val = 0;</span><br><span class="hljs-comment"> *   TreeNode left = null;</span><br><span class="hljs-comment"> *   TreeNode right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 利用队列的性质</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root TreeNode类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span> <span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-comment">//结果</span><br>        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//每层临时结果</span><br>        ArrayList&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        TreeNode node;<br>        <span class="hljs-comment">//队列</span><br>        LinkedList&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        list.add(root);<br>        <span class="hljs-comment">//给定个 层标识</span><br>        list.add(<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//遍历队列</span><br>        <span class="hljs-keyword">while</span> (!list.isEmpty()) &#123;<br>            node = list.removeFirst();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != node) &#123;<br>                temp.add(node.val);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != node.left) &#123;<br>                    list.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != node.right) &#123;<br>                    list.add(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//为null节点，说明这一层已经遍历完成</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//这里一定要判断下，如果为空，表明二叉树已经遍历完成了</span><br>                <span class="hljs-keyword">if</span> (!temp.isEmpty()) &#123;<br>                    res.add(temp);<br>                    temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    list.add(<span class="hljs-literal">null</span>);<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-comment">//记录输出</span><br>    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <br><span class="hljs-comment">//递归</span><br><span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span> <span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">//如果是空，则直接返回</span><br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">//递归层次遍历</span><br>        traverse(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">//临时结果集</span><br>    ArrayList&lt;Integer&gt; row;<br>    <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//新的一层: 对于二维res来说，将根视为第0层，树的深度正好等于一维res的个数</span><br>            <span class="hljs-keyword">if</span>(res.size() == depth)&#123; <br>                row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>                res.add(row);<br>            <span class="hljs-comment">//读取该层的一维数组，将元素加入末尾</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                row = res.get(depth); <br>            &#125;<br>            row.add(root.val);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//递归左右时深度记得加1</span><br>        traverse(root.left, depth + <span class="hljs-number">1</span>);<br>        traverse(root.right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】144.二叉树的前序遍历</title>
    <link href="/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2023/04/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">给你二叉树的根节点<span class="hljs-built_in"> root</span> ，返回它节点值的 前序 遍历。<br></code></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/bfcfd742f58b7f629df27b4bf8a169a9.jpeg#pic_center" alt="图1"></p><blockquote><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]</p></blockquote><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><blockquote><p>输入：root &#x3D; []<br>输出：[]</p></blockquote><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><blockquote><p>输入：root &#x3D; [1]<br>输出：[1]</p></blockquote><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/055d4e3cd757f49afe71b8e1467d480a.jpeg#pic_center" alt="图2"></p><blockquote><p>输入：root &#x3D; [1,2]<br>输出：[1,2]</p></blockquote><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/1e3a847f0b72e64b899dbeb0dcbca616.jpeg#pic_center" alt="图3"></p><blockquote><p>输入：root &#x3D; [1,null,2]<br>输出：[1,2]</p></blockquote><p><strong>提示</strong>：</p><ul><li>树中节点数目在范围 [0, 100] 内</li><li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li></ul><h1 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h1><h2 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1 递归"></a>2.1 递归</h2><p>中序遍历的规则是 根-左-右，然后访问左子树、右子树时同样按照此规则遍历，非常容易通过递归实现，按照规则，代码非常容易写出来。定义 <strong>preorderTraversal(root)</strong> 为递归遍历函数方法，root 为根节点。伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">root.val;<br>preorderTraversal(root.left);<br>preorderTraversal(root.right);<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p></li><li><p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log⁡n)，最坏情况下树呈现链状，为 O(n)。</p></li></ul><h2 id="2-2-迭代"><a href="#2-2-迭代" class="headerlink" title="2.2 迭代"></a>2.2 迭代</h2><p>显示利用栈结构，遍历二叉树。<br>引用LeetCode动态图解迭代过程：<br>1）访问根节点<br><img src="https://img-blog.csdnimg.cn/img_convert/9d2a4485420c7a95799a09999b81d662.png#pic_center" alt="图4"><br>2）根节点入栈<br><img src="https://img-blog.csdnimg.cn/img_convert/64301bc1906294b4853a32161890f3ec.png#pic_center" alt="图5"><br>3）左子树根节点遍历、入栈<br><img src="https://img-blog.csdnimg.cn/img_convert/625bc2dd91f7e489d64311098b60599c.png#pic_center" alt="图6"><br>4）左子树根节点出栈，遍历其左右子节点<br><img src="https://img-blog.csdnimg.cn/img_convert/1795695bfe91736dd9daba150dc75b02.png#pic_center" alt="图7"><br>5）左根节点左子树不存在，遍历其右子树4<br><img src="https://img-blog.csdnimg.cn/img_convert/053fb2ab6e498be02df4e0b7c1e8bd78.png#pic_center" alt="图8"><br>6）左子树遍历完毕，遍历根节点右子树<br><img src="https://img-blog.csdnimg.cn/img_convert/92ba07a2ab80979a6adcbb932f43c0ad.png#pic_center" alt="图9"><br>7）遍历右子树根节点，根节点出栈<br><img src="https://img-blog.csdnimg.cn/img_convert/d19f60849640fb1625a0424b3cbde631.png#pic_center" alt="图10"><br>8）右子树根节点入栈<br><img src="https://img-blog.csdnimg.cn/img_convert/2db7363f3e0366a1b2242fb703c95751.png#pic_center" alt="图11"></p><p>9）右子树左节点遍历，入栈<br><img src="https://img-blog.csdnimg.cn/img_convert/0df77d13242bf0d1028476a613d15084.png#pic_center" alt="图12"></p><p>10）右子树左节点遍历完毕，该节点出栈<br><img src="https://img-blog.csdnimg.cn/img_convert/3a874f3193e082298063797fc8fba000.png#pic_center" alt="图13"><br>11）遍历右子树右节点，右子树根节点出栈<br><img src="https://img-blog.csdnimg.cn/img_convert/62cd727620a3733c5b93de45ef8c8d83.png#pic_center" alt="图14"><br>12）右子树右节点遍历，入栈<br><img src="https://img-blog.csdnimg.cn/img_convert/44473bed64019699f1a718508dbf4a24.png#pic_center" alt="图15"><br>13）右子树遍历完毕，出栈<br><img src="https://img-blog.csdnimg.cn/img_convert/87b30e5ca23edf3bee8fe942d99b7e4b.png#pic_center" alt="图16"><br>14）遍历完毕<br><img src="https://img-blog.csdnimg.cn/img_convert/c2cee3c4c3edf74912ccc14b9dbba9af.png#pic_center" alt="图17"><br><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p></li><li><p>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(log⁡n)，最坏情况下树呈现链状，为 O(n)。</p></li></ul><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root TreeNode类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型一维数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] preorderTraversal (TreeNode root) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        preorderTraversal2(list, root);<br>        <span class="hljs-keyword">return</span> list.stream().mapToInt(Integer::valueOf).toArray();<br>    &#125;<br> <br> <span class="hljs-comment">//递归方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorderTraversal2</span> <span class="hljs-params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        list.add(root.val);<br>        preorderTraversal2(list, root.left);<br>        preorderTraversal2(list, root.right);<br>    &#125;<br><br><span class="hljs-comment">//迭代，栈思想</span><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.add(root);<br>        TreeNode p;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            p = stack.pop();<br>            res.add(p.val);<br>            <span class="hljs-comment">//先把右节点入栈</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != p.right) &#123;<br>                stack.add(p.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != p.left) &#123;<br>                stack.add(p.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/28/hello-world/"/>
    <url>/2023/04/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
